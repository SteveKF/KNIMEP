package org.knime;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.knime.core.data.DataCell;
import org.knime.core.data.DataRow;
import org.knime.core.data.DoubleValue;
import org.knime.core.node.BufferedDataTable;

public class RepresentativeSkyline {

	private BufferedDataTable skyData;
	private List<DataPoint> skyline;

	private Map<DataPoint, Map<DataPoint, Double>> objFunction;
	private Map<DataPoint, Map<DataPoint, Double>> skyEditDist;
	private Map<DataPoint, Map<DataPoint, Double>> reverseSkyEditDist;
	private Map<DataPoint, Double> skySigmSignificance;

	private double[][] threshold;
	private DataPoint maxSigRecord;

	private int k;
	private double lambda = 0.5;
	private int[] colIndexes;

	public RepresentativeSkyline(BufferedDataTable skyData, int k, int[] colIndexes, double[][] threshold) {
		this.skyData = skyData;
		this.k = k;
		this.colIndexes = colIndexes;
		this.threshold = threshold;

		skyline = new LinkedList<>();
		skyEditDist = new HashMap<>();
		skySigmSignificance = new HashMap<>();
		objFunction = new HashMap<>();

		for (DataRow row : skyData) {
			skyline.add(createDataPoint(row));
		}

		computeValues();

		for (int i = 0; i < skyline.size(); i++) {
			DataPoint p = skyline.get(i);
			for (int j = 0; j < skyline.size(); j++) {
				DataPoint q = skyline.get(j);
				HashMap<DataPoint, Double> tmp = new HashMap<>();
				
				double value = skyEditDist.get(p).get(q) * lambda + skySigmSignificance.get(q) * lambda;
				tmp.put(q, value);
				objFunction.put(p, tmp);
			}
		}
	}

	private List<DataPoint> EGreedy() {
		List<DataPoint> result = new LinkedList<DataPoint>();

		result.add(maxSigRecord);

		for (int i = 0; i < k - 1; i++) {
			result.add(getNextPoint(result));
		}

		return result;
	}

	private DataPoint getNextPoint(List<DataPoint> result) {
		
		DataPoint next;
		double max = Double.MIN_VALUE;
		
		for(int i=0; i < result.size(); i++){
			for(int j=0; j < skyline.size(); j++){
				
			double value = objFunction.get(skyline.get(j)).get(result.get(i));
			int compareVal = Double.compare(value, max);
			if(compareVal > 0){
				max = value;
				next = skyline.get(j);
			}
			
				
			}
		}
		
		return next;
	}
	

	private List<DataPoint> EPrefix() {
		// Input: Skyline und k int
		List<DataPoint> result = EGreedy();

		return Sparsify(result);

	}

	private List<DataPoint> Sparsify(List<DataPoint> repSkyline) {
		List<DataPoint> result = new LinkedList<>();

		int p = 0;
		double max = Double.MIN_VALUE;

		for (int i = 0; i < k - 1; i++) {
			double tmpMax = Double.MAX_VALUE;

			for (int n = 0; n <= i; n++) {
				double value = objFunction.get(repSkyline.get(i + 1)).get(repSkyline.get(n));
				int compareVal = Double.compare(value, tmpMax);
				if (compareVal < 0) {
					tmpMax = value;
				}
			}

			int compareVal = Double.compare(tmpMax * i, max);
			if (compareVal > 0) {
				max = tmpMax * i;
				p = i;
			}

			max /= i;
		}

		List<LinkedList<DataPoint>> s = new LinkedList<LinkedList<DataPoint>>();
		for (int i = 0; i < p; i++) {
			for (int m = 0; m < skyline.size(); m++) {
				double value = objFunction.get(result.get(i)).get(skyline.get(m));
				int compareVal = Double.compare(value, max);
				if (compareVal <= 0) {
					s.get(i).add(skyline.get(m));
				}
			}
		}

		bubbleSort(s);

		for (int i = 0; i < p / 2; i++) {
			for (int j = 0; j < s.get(i).size(); j++) {
				if (j >= p / 2) {
					break;
				}
				result.add(s.get(i).get(j));
			}
		}

		while (result.size() < k) {
			// result.add
		}

		return result;
	}

	private void bubbleSort(List<LinkedList<DataPoint>> l) {
		for (int n = l.size(); n > 1; n = n - 1) {
			for (int i = 0; i < n - 1; i = i + 1) {
				if (l.get(i).size() > l.get(i + 1).size()) {
					LinkedList<DataPoint> tmp = l.get(i);
					l.set(i, l.get(i + 1));
					l.set(i + 1, tmp);
				}
			}
		}
	}

	private void computeValues() {

		double max = 0.0;
		boolean isComputed = false;

		for (int i = 0; i < skyline.size(); i++) {
			DataPoint p = skyline.get(i);
			HashMap<DataPoint, Double> tmp = new HashMap<>();

			for (int j = 0; j < skyline.size(); j++) {
				DataPoint q = skyline.get(j);
				tmp.put(q, computeSkyEditDist(p, q));

				if (!isComputed) {
					max = computeSkySigmSig(q, max);
				}
			}

			isComputed = true;

			skyEditDist.put(p, tmp);

			skySigmSignificance.replace(p, skySigmSignificance.get(p) / max);
		}
	}

	private double computeSkySigmSig(DataPoint r, double max) {

		double logit = computeLogit(r);
		skySigmSignificance.put(r, logit);

		int compareVal = Double.compare(logit, max);
		if (compareVal > 0) {
			max = logit;
			maxSigRecord = r;
		}

		return max;

	}

	// computes logit
	private double computeLogit(DataPoint r) {

		double result = 0.0;

		for (int i = 0; i < colIndexes.length; i++) {

			// no intervall for dimension i
			if (threshold[i][1] == 0.0) {

				result += 1 / (1 + Math.exp(-r.getCoordinateAt(i) + threshold[i][0]));

			} else {

				result += ((-Math.log(1 + Math.exp(r.getCoordinateAt(i) - threshold[i][1])))
						+ (Math.log(1 + Math.exp(r.getCoordinateAt(i) - threshold[i][0]))))
						/ (threshold[i][1] - threshold[i][0]);

			}
		}
		return (result / colIndexes.length);
	}

	private double computeSkyEditDist(DataPoint p, DataPoint q) {

		// sum of all the fraction of the skyline in each dimension
		double[] sumFracSky = new double[colIndexes.length];

		for (int i = 0; i < colIndexes.length; i++) {

			int diversity = 0;
			int compareVal = Double.compare(p.getCoordinateAt(i), q.getCoordinateAt(i));
			if (compareVal > 0) {
				diversity = computeDiversity(p, q, i);
			} else if (compareVal < 0) {
				diversity = computeDiversity(q, p, i);
			} else if (!p.equals(q)) {
				diversity = computeDiversity(p, q, i);
			}
			// else it stays 0

			if (diversity != 0) {
				sumFracSky[i] = (diversity - 1.0) / (skyline.size() - 1.0);
			} else {
				sumFracSky[i] = 0.0;
			}
		}

		double result = 0.0;
		for (int i = 0; i < sumFracSky.length; i++) {
			result += sumFracSky[i];
		}

		result /= colIndexes.length;

		return result;
	}

	private int computeDiversity(DataPoint r, DataPoint s, int index) {

		int diversity = 0;
		for (int i = 0; i < skyline.size(); i++) {
			DataPoint o = skyline.get(i);
			if (r.getCoordinateAt(index) >= o.getCoordinateAt(index)
					&& o.getCoordinateAt(index) >= s.getCoordinateAt(index)) {
				diversity++;
			}
		}

		return diversity;
	}

	private DataPoint createDataPoint(DataRow row) {
		double[] values = new double[colIndexes.length];
		for (int i = 0; i < colIndexes.length; i++) {
			DataCell currCell = row.getCell(colIndexes[i]);
			values[i] = ((DoubleValue) currCell).getDoubleValue();
		}

		DataPoint p = new DataPoint(values, row);

		return p;
	}

	public class DataPoint {

		private DataRow row;
		private double[] coords;

		public DataPoint(double[] coords, DataRow row) {
			this.row = row;
			this.coords = coords;
		}

		public double[] getCoordinates() {
			return coords;
		}

		public double getCoordinateAt(int index) {
			return coords[index];
		}

		public DataRow getDataRow() {
			return row;
		}

	}
}
