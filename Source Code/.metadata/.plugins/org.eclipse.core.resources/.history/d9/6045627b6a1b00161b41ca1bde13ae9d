import java.util.List;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;

public class BNL {

	private final int wSize;
	private final int numDims;

	private int iteration;

	private List<DataPoint> window;
	private List<DataPoint> tmpFile;
	private List<DataPoint> points;
	private List<DataPoint> output;

	/**
	 * Block Nested Loop Algorithm
	 * 
	 * @param wSize
	 *            maximum size of the window
	 * @param numDims
	 *            the number of dimensions of the points which will be added
	 */
	public BNL(int wSize, int numDims) {
		assert (wSize > 0 && numDims > 0);
		this.wSize = wSize;
		this.numDims = numDims;
		points = new LinkedList<>();
	}

	public void addPoint(float[] point) {
		assert (point.length == numDims);
		points.add(new DataPoint(point, 0));
	}

	public void computeSky() {
		initialize();
		while (points.size() != 0 || tmpFile.size() != 0) {
			if(iteration==0){
				scanDatabase(input);
			}else{
				scanDatabase(tmpFile);
			}
			// flushMemory();
		}

		for (DataPoint p : output) {
			System.out.println(p);
		}
	}

	private void initialize() {
		tmpFile = new LinkedList<>();
		window = new LinkedList<>();
		output = new LinkedList<>();
		iteration = 0;

		input.get(0).setEmpty(true);
		window.add(input.get(0));
		input.remove(0);
	}

	private void scanDatabase(List<DataPoint> input) {

		while (input.size() != 0) {
			nestedLoop(input);
		}

		for (DataPoint p : window) {
			if (p.getTimestamp() == iteration + 1 || p.getEmpty() == true) {
				output.add(p);
				window.remove(p);
			}
		}

		iteration++;
	}

	private void nestedLoop(List<DataPoint> input) {
		for (DataPoint p : input) {

			for (DataPoint q : window) {
				if (dominates(q.getCoordinates(), p.getCoordinates())) {
					input.remove(p);
					return;
				} else if (dominates(p.getCoordinates(), q.getCoordinates())) {
					window.remove(q);
				}
			}

			if (window.size() >= wSize) {
				tmpFile.add(p);
				input.remove(p);
			} else {
				if (tmpFile.size() == 0) {
					p.setEmpty(true);
				}
				p.setTimestamp(iteration);
				window.add(p);
				input.remove(p);
			}
		}
	}

	private void flushMemory() {
		for (DataPoint p : window) {
			output.add(p);
			window.remove(p);
		}
	}

	private boolean dominates(float[] a, float[] b) {
		int domDims = 0;
		for (int i = 0; i < numDims; i++) {
			if (a[i] < b[i]) {
				domDims += 2;
			} else if (a[i] == b[i]) {
				domDims++;
			}
		}
		if (domDims > numDims) {
			return true;
		} else {
			return false;
		}
	}

	private class DataPoint {

		private float[] coords;
		private int timestamp;
		private boolean empty;

		private DataPoint(float[] coords, int timestamp) {
			assert (coords.length == numDims);
			this.coords = coords;
			this.timestamp = timestamp;
		}

		public float[] getCoordinates() {
			return coords;
		}

		public void setCoordinates(float[] coords) {
			this.coords = coords;
		}

		public int getTimestamp() {
			return timestamp;
		}

		public void setTimestamp(int timestamp) {
			this.timestamp = timestamp;
		}

		public boolean getEmpty() {
			return empty;
		}

		public void setEmpty(boolean empty) {
			this.empty = empty;
		}
	}
}
