package org.knime;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;

import javax.swing.JRadioButton;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.knime.core.data.DataRow;
import org.knime.core.data.DataTableSpec;
import org.knime.core.node.BufferedDataTable;
import org.knime.core.node.DataAwareNodeDialogPane;
import org.knime.core.node.InvalidSettingsException;
import org.knime.core.node.NodeSettingsRO;
import org.knime.core.node.NodeSettingsWO;
import org.knime.core.node.NotConfigurableException;
import org.knime.core.node.defaultnodesettings.DefaultNodeSettingsPane;
import org.knime.core.node.defaultnodesettings.DialogComponentBoolean;
import org.knime.core.node.defaultnodesettings.DialogComponentButton;
import org.knime.core.node.defaultnodesettings.DialogComponentButtonGroup;
import org.knime.core.node.defaultnodesettings.DialogComponentColumnFilter;
import org.knime.core.node.defaultnodesettings.DialogComponentDoubleRange;
import org.knime.core.node.defaultnodesettings.DialogComponentLabel;
import org.knime.core.node.defaultnodesettings.DialogComponentNumber;
import org.knime.core.node.defaultnodesettings.DialogComponentNumberEdit;
import org.knime.core.node.defaultnodesettings.DialogComponentStringSelection;
import org.knime.core.node.defaultnodesettings.SettingsModelBoolean;
import org.knime.core.node.defaultnodesettings.SettingsModelDouble;
import org.knime.core.node.defaultnodesettings.SettingsModelDoubleRange;
import org.knime.core.node.defaultnodesettings.SettingsModelFilterString;
import org.knime.core.node.defaultnodesettings.SettingsModelInteger;
import org.knime.core.node.defaultnodesettings.SettingsModelString;
import org.knime.core.node.port.PortObject;
import org.knime.core.node.port.PortObjectSpec;
import org.knime.core.node.port.flowvariable.FlowVariablePortObject;
import org.knime.core.node.port.flowvariable.FlowVariablePortObjectSpec;

/**
 * <code>NodeDialog</code> for the "RepresentativeSkyline" Node. An algorithm
 * which computes a k-representative skyline based on significance and
 * diversity. * n
 * 
 * @author Stefan Wohlfart
 */
public class RepresentativeSkylineNodeDialog extends DataAwareDefaultNodeSettingsPane {

	private LinkedList<String> minList;
	private LinkedList<String> maxList;
	public static final String CFGKEY_THRESHHOLD_OPTIONS_MAX = "max_threshholdOptionsModel";
	public static final String CFGKEY_THRESHHOLD_SINGLE_MAX = "threshholdSingleMax";
	public static final String CFGKEY_THRESHHOLD_RANGE_MAX = "threshholdRangeMax";
	public static final String CFGKEY_SELECTION_MAX = "selectionMax";

	public SettingsModelDouble max_singleModel;
	public SettingsModelDoubleRange max_rangeModel;
	public SettingsModelString max_threshholdOptionsModel;
	public SettingsModelString max_selectionModel;

	private EventHandler max_handler;
	private boolean isCreated = false;

	public enum threshholdOptions {
		SINGLE, RANGE, NONE
	}

	public String max_prevColumn;
	public static HashMap<String, String> max_optionMap = new HashMap<>();
	public static HashMap<String, Double> max_singleThreshholdMap = new HashMap<>();
	public static HashMap<String, double[]> max_rangeThreshholdMap = new HashMap<>();

	/**
	 * New pane for configuring RepresentativeSkyline node dialog. This is just
	 * a suggestion to demonstrate possible default dialog components.
	 */
	protected RepresentativeSkylineNodeDialog() {
		super();

		// initialize fields
		minList = new LinkedList<>();
		maxList = new LinkedList<>();
		max_threshholdOptionsModel = new SettingsModelString(CFGKEY_THRESHHOLD_OPTIONS_MAX,
				threshholdOptions.NONE.toString());
		max_singleModel = new SettingsModelDouble(CFGKEY_THRESHHOLD_SINGLE_MAX, 0.0);
		max_rangeModel = new SettingsModelDoubleRange(CFGKEY_THRESHHOLD_RANGE_MAX, 0.0, 5.0);
		max_singleModel.setEnabled(false);
		max_rangeModel.setEnabled(false);

		// addDialogComponent(new DialogComponentNumber(
		// new SettingsModelInteger(RepresentativeSkylineNodeModel.CFGKEY_K, 2),
		// "k", 1));
		//
		// createNewTabAt("Maximized Dimensions", 0);
		// addDialogComponent(new DialogComponentLabel("Choose Dimensions which"
		// + "should be maximized."));
		//
		// addDialogComponent(new DialogComponentColumnFilter(
		// new
		// SettingsModelFilterString(RepresentativeSkylineNodeModel.CFGKEY_MAX_DIMENSIONS),
		// RepresentativeSkylineNodeModel.IN_PORT_SKYLINE, false));
		//
		// createNewTabAt("Minimized Dimensions", 1);
		// addDialogComponent(new DialogComponentLabel("Choose Dimensions which"
		// + "should be minimized"));
		//
		// addDialogComponent(new DialogComponentColumnFilter(
		// new
		// SettingsModelFilterString(RepresentativeSkylineNodeModel.CFGKEY_MIN_DIMENSIONS),
		// RepresentativeSkylineNodeModel.IN_PORT_SKYLINE, false));
	}

	@Override
	public void loadSettingsFrom(NodeSettingsRO settings, PortObject[] input) throws NotConfigurableException {

		if (!isCreated) {
			isCreated = true;
			// access data input which dimension should be minimized or
			// maximized
			for (DataRow row : (BufferedDataTable) input[RepresentativeSkylineNodeModel.IN_PORT_FLOW]) {
				for (int i = 0; i < row.getNumCells(); i++) {
					if (!row.getCell(i).isMissing()) {
						if (i == 0) {
							minList.add(row.getCell(i).toString());
						} else {
							maxList.add(row.getCell(i).toString());
						}
					}
				}
			}

			// initialize fields which needs input information
			max_selectionModel = new SettingsModelString(CFGKEY_SELECTION_MAX, maxList.getFirst());
			max_prevColumn = maxList.getFirst();
			for (int i = 0; i < maxList.size(); i++) {
				double tmp_single = 0.0;
				double[] tmp_range = new double[] { 0.0, 5.0 };
				max_optionMap.put(maxList.get(i), threshholdOptions.NONE.toString());
				max_singleThreshholdMap.put(maxList.get(i), tmp_single);
				max_rangeThreshholdMap.put(maxList.get(i), tmp_range);
			}

			// add components
			createNewTabAt("Threshhold", 0);
			createNewGroup("Maximized Dimension");
			addDialogComponent(new DialogComponentStringSelection(max_selectionModel, "Dimensions", maxList));
			addDialogComponent(new DialogComponentButtonGroup(max_threshholdOptionsModel, false, "Threshhold",
					threshholdOptions.SINGLE.toString(), threshholdOptions.RANGE.toString(),
					threshholdOptions.NONE.toString()));
			addDialogComponent(new DialogComponentNumberEdit(max_singleModel, "Threshhold Single"));
			addDialogComponent(
					new DialogComponentDoubleRange(max_rangeModel, 0.0, Double.MAX_VALUE, 0.5, "Threshhold Range"));
			closeCurrentGroup();

			// set listener
			max_handler = new EventHandler();
			max_selectionModel.addChangeListener(max_handler);
			max_singleModel.addChangeListener(max_handler);
			max_rangeModel.addChangeListener(max_handler);
			max_threshholdOptionsModel.addChangeListener(max_handler);
		}

		super.loadSettingsFrom(settings, input);

	}

	private void saveValues(String key) {

		// save which option was chosen
		if (max_optionMap.replace(key, max_threshholdOptionsModel.getStringValue()) == null) {
			max_optionMap.put(key, max_threshholdOptionsModel.getStringValue());
		}

		// save values
		if (max_threshholdOptionsModel.getStringValue() == threshholdOptions.SINGLE.toString()) {
			if (max_singleThreshholdMap.replace(key, max_singleModel.getDoubleValue()) == null) {
				max_singleThreshholdMap.put(key, max_singleModel.getDoubleValue());
			}
		} else if (max_threshholdOptionsModel.getStringValue() == threshholdOptions.RANGE.toString()) {
			double[] tmp = new double[] { max_rangeModel.getMinRange(), max_rangeModel.getMinRange() };
			if (max_rangeThreshholdMap.replace(key, tmp) == null) {
				max_rangeThreshholdMap.put(key, tmp);
			}
		} // else do nothing

		max_selectionModel.addChangeListener(max_handler);
		max_singleModel.addChangeListener(max_handler);
		max_rangeModel.addChangeListener(max_handler);
		max_threshholdOptionsModel.addChangeListener(max_handler);
	}

	private void loadValues(String key) {

		max_selectionModel.removeChangeListener(max_handler);
		max_singleModel.removeChangeListener(max_handler);
		max_rangeModel.removeChangeListener(max_handler);
		max_threshholdOptionsModel.removeChangeListener(max_handler);
		
		max_threshholdOptionsModel.setStringValue(max_optionMap.get(key));
		disableComponents();
		if (max_threshholdOptionsModel.getStringValue() == threshholdOptions.SINGLE.toString()) {
			max_singleModel.setDoubleValue(max_singleThreshholdMap.get(key));
		} else if (max_threshholdOptionsModel.getStringValue() == threshholdOptions.RANGE.toString()) {
			double[] tmp = max_rangeThreshholdMap.get(key);
			// set both values of max and min
		} // else do nothing
	}

	private class EventHandler implements ChangeListener {

		max_selectionModel.removeChangeListener(max_handler);
		max_singleModel.removeChangeListener(max_handler);
		max_rangeModel.removeChangeListener(max_handler);
		max_threshholdOptionsModel.removeChangeListener(max_handler);
		
		@Override
		public void stateChanged(ChangeEvent e) {
			
			if (e.getSource() == max_selectionModel && max_prevColumn != max_selectionModel.getStringValue()) {
				saveValues(max_prevColumn);
				max_prevColumn = max_selectionModel.getStringValue();
				loadValues(max_prevColumn);
				saveValues(max_prevColumn);
				System.out.println("Change in Selection");

			} else if (e.getSource() == max_singleModel && max_singleThreshholdMap.get(max_selectionModel.getStringValue()) != max_singleModel.getDoubleValue()) {
				saveValues(max_threshholdOptionsModel.getStringValue());
				System.out.println("Change in Single");

			} else if (e.getSource() == max_rangeModel && max_rangeThreshholdMap.get(max_selectionModel.getStringValue())[0] != max_rangeModel.getMinRange() && max_rangeThreshholdMap.get(max_selectionModel.getStringValue())[1] != max_rangeModel.getMaxRange()) {
				saveValues(max_threshholdOptionsModel.getStringValue());
				System.out.println("Change in Range");

			} else if (e.getSource() == max_threshholdOptionsModel && max_optionMap.get(max_selectionModel.getStringValue())!= max_threshholdOptionsModel.getStringValue()) {
				disableComponents();
				saveValues(max_threshholdOptionsModel.getStringValue());
				System.out.println("Change in Options");
				
			}

//			for (int i = 0; i < maxList.size(); i++) {
//				System.out.println(maxList.get(i));
//				System.out.println("Option: " + max_optionMap.get(maxList.get(i)));
//				System.out.println("Single: " + max_singleThreshholdMap.get(maxList.get(i)));
//				System.out.print("Range: " + max_rangeThreshholdMap.get(maxList.get(i))[0]);
//				System.out.println(", " + max_rangeThreshholdMap.get(maxList.get(i))[1]);
//				System.out.println();
//				System.out.println();
//			}
//			System.out.println("---------------------------");
			
			max_selectionModel.addChangeListener(max_handler);
			max_singleModel.addChangeListener(max_handler);
			max_rangeModel.addChangeListener(max_handler);
			max_threshholdOptionsModel.addChangeListener(max_handler);
			
		}
	}

	private void disableComponents() {
		if (max_threshholdOptionsModel.getStringValue() == threshholdOptions.SINGLE.toString()) {
			if(!max_singleModel.isEnabled()) 
				max_singleModel.setEnabled(true);
			if(max_rangeModel.isEnabled())
				max_rangeModel.setEnabled(false);
		} else if (max_threshholdOptionsModel.getStringValue() == threshholdOptions.RANGE.toString()) {
			if(max_singleModel.isEnabled())
				max_singleModel.setEnabled(false);
			if(!max_rangeModel.isEnabled())
				max_rangeModel.setEnabled(true);
		} else {
			if(max_singleModel.isEnabled())
				max_singleModel.setEnabled(false);
			if(max_rangeModel.isEnabled())
				max_rangeModel.setEnabled(false);
		}
	}

	private void enableComponents() {
		if (!max_singleModel.isEnabled()) {
			max_singleModel.setEnabled(true);
		}
		if (!max_rangeModel.isEnabled()) {
			max_rangeModel.setEnabled(true);
		}
	}
}