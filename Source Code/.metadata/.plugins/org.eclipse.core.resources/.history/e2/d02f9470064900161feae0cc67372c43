package org.knime.bnl;

import java.util.LinkedList;
import org.knime.core.data.DataCell;
import org.knime.core.data.DataRow;
import org.knime.core.data.DoubleValue;
import org.knime.core.data.container.CloseableRowIterator;
import org.knime.core.node.BufferedDataTable;


public class BNL {
	
	private final int wSize;
	private final int numDims;
	private final int[] colIndexes;
	private final Domination[] dom;

	private long timestampCounter;

	private BufferedDataTable data;
	private LinkedList<DataPoint> window;
	private LinkedList<DataPoint> tmpFile;
	private LinkedList<DataPoint> input;
	private LinkedList<DataPoint> output;
	
	private LinkedList<LinkedList<DataCell>> skyline;
	private LinkedList<LinkedList<DataCell>> dominatedPoints;

	public enum Domination {
		GREATER, LESS
	}

	/**
	 * Block Nested Loop Algorithm
	 * 
	 * @param input
	 *            the input table
	 * @param wSize
	 *            maximum size of the window
	 * @param dom
	 *            for each dimension the domination rule (e.g. we want to be
	 *            dimension x as big as possible)
	 */
	public BNL(BufferedDataTable data, int wSize, int[] colIndexes, Domination dom[]) {
		numDims = colIndexes.length;
		assert (wSize > 0 && numDims > 0 && dom.length == numDims);
		this.data = data;
		this.wSize = wSize;
		this.colIndexes = colIndexes;
		this.dom = dom;
	}
	
 
	/**
	 * Computes the skyline if at least one point was added
	 */
	public void computeSky() {
		assert (data.size() > 0);
		initialize();
		// first iteration
		input = scanDatabase(data);
		// the second and following iterations

		while (input.size() != 0) {
			input = nestedLoop(input);
		}
		flushMemory();
	}

	private void initialize() {
		tmpFile = new LinkedList<>();
		window = new LinkedList<>();
		input = new LinkedList<>();
		output = new LinkedList<>();
		
		skyline = new LinkedList<>();
		dominatedPoints = new LinkedList<>();
		
		timestampCounter = 1;
	}

	// overloaded method for first iteration to save I/O costs
	private LinkedList<DataPoint> scanDatabase(BufferedDataTable data) {

		// put first element into window
		CloseableRowIterator it = data.iterator();
		DataPoint firstPoint = createDataPoint(it.next());
		
		
		firstPoint.setTimestamp(timestampCounter++);
		window.add(firstPoint);
		LinkedList<DataPoint> tmpList2 = new LinkedList<>(window);
		
		dominatedPoints.add(firstPoint.getDataRow());

		while (it.hasNext()) {

			DataPoint p = createDataPoint(it.next());
			
			dominatedPoints.add(p.getDataRow());


			boolean isDominated = false;

			for (DataPoint q : window) {

				if (dominates(q.getCoordinates(), p.getCoordinates())) {
					isDominated = true;
					break;
				} else if (dominates(p.getCoordinates(), q.getCoordinates())) {
					tmpList2.remove(q);
				}
			}
			if (!isDominated) {
				if (tmpList2.size() >= wSize) {
					p.setTimestamp(timestampCounter++);
					tmpFile.add(p);
				} else {
					p.setTimestamp(timestampCounter++);
					tmpList2.add(p);
				}
			}

			window = new LinkedList<>(tmpList2);
		}

		LinkedList<DataPoint> l = new LinkedList<DataPoint>(tmpFile);
		tmpFile = new LinkedList<>();

		return l;
	}

	private LinkedList<DataPoint> nestedLoop(LinkedList<DataPoint> l) {

		LinkedList<DataPoint> tmpList2 = new LinkedList<>(window);

		for (DataPoint p : l) {

			boolean isDominated = false;

			for (DataPoint q : window) {

				if (q.getTimestamp() < p.getTimestamp()) {
					output.add(q);
					skyline.add(q.getDataRow());
					dominatedPoints.remove(q.getDataRow());
					tmpList2.remove(q);
				} else {

					if (dominates(q.getCoordinates(), p.getCoordinates())) {
						isDominated = true;
						break;
					} else if (dominates(p.getCoordinates(), q.getCoordinates())) {
						tmpList2.remove(q);
					}

				}
			}
			if (!isDominated) {
				if (tmpList2.size() >= wSize) {
					p.setTimestamp(timestampCounter++);
					tmpFile.add(p);
				} else {
					p.setTimestamp(timestampCounter++);
					tmpList2.add(p);
				}
			}

			window = new LinkedList<>(tmpList2);
		}

		LinkedList<DataPoint> result = new LinkedList<>(tmpFile);
		tmpFile = new LinkedList<>();

		return result;
	}

	private void flushMemory() {
		for (DataPoint p : window) {
			output.add(p);
			skyline.add(p.getDataRow());
			dominatedPoints.remove(p.getDataRow());
		}
	}

	private DataPoint createDataPoint(DataRow row) {
		double[] values = new double[colIndexes.length];
		for (int i = 0; i < colIndexes.length; i++) {
			DataCell currCell = row.getCell(colIndexes[i]);
			values[i] = ((DoubleValue) currCell).getDoubleValue();
		}

		DataPoint p = new DataPoint(values, 0 /* Timestamp at 0 */
				, row);

		return p;
	}

	public LinkedList<DataRow> getSkyline() {
		return skyline;
	}
	
	public LinkedList<LinkedList<DataCell>> getDominatedPoints(){
		return dominatedPoints;
	}
	
	public void addDominatedPoint(DataRow row){
		
		LinkedList<DataCell> tmp = new LinkedList<>();
		
		for(int i=0; i < row.getNumCells(); i++){
			tmp.add(row.getCell(i));
		}
		
		dominatedPoints.add(tmp);
	}
	
	public void addSkylinePoint(DataRow row){
		
		LinkedList<DataCell> tmp = new LinkedList<>();
		
		for(int i=0; i < row.getNumCells(); i++){
			tmp.add(row.getCell(i));
		}
		
		skyline.add(tmp);
	}
		
	private boolean dominates(double[] a, double[] b) {
		int countDominance = 0;
		int countEquals = 0;
		for (int i = 0; i < numDims; i++) {
			int compareVal = Double.compare(a[i], b[i]);
			if (dom[i] == Domination.LESS && compareVal < 0) {
				countDominance++;
			} else if (dom[i] == Domination.GREATER && compareVal > 0) {
				countDominance++;
			} else if (compareVal == 0) {
				countEquals++;
			}
		}
		if (countDominance == numDims) {
			return true;
		}else if(countDominance + countEquals < numDims){
			return false;
		}else if (countEquals == numDims) {
			return false;
		} else if (countEquals + countDominance == numDims) {
			return true;
		}else{
			return false;
		}
	}
		
 
	public class DataPoint {

		private final double[] coords;
		private long timestamp;
		private DataRow row;

		public DataPoint(double[] coords, int timestamp, DataRow row) {
			assert (coords.length == numDims);
			this.coords = coords;
			this.timestamp = timestamp;
			this.row = row;
		}

		private DataRow getDataRow() {
			return row;
		}

		public double[] getCoordinates() {
			return coords;
		}

		private long getTimestamp() {
			return timestamp;
		}

		private void setTimestamp(long timestamp) {
			this.timestamp = timestamp;
		}
	}
}
